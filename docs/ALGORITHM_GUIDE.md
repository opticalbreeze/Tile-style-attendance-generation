# 🏥 シフト自動アテンド アルゴリズム解説

**対象読者**: プログラミング初学者・シフト管理に興味がある方  
**前提知識**: JavaScriptの基本文法（変数、配列、ループ、関数）

---

## 📚 目次

1. [はじめに：このシステムは何をするのか](#1-はじめにこのシステムは何をするのか)
2. [勤務の種類と制約ルール](#2-勤務の種類と制約ルール)
3. [アルゴリズムの全体像](#3-アルゴリズムの全体像)
4. [Step 1: 事前準備](#4-step-1-事前準備)
5. [Step 2: スタッフの配置可能性を計算](#5-step-2-スタッフの配置可能性を計算)
6. [Step 3: 24勤の割り当て](#6-step-3-24勤の割り当て)
7. [Step 4: 日勤で時間を補完](#7-step-4-日勤で時間を補完)
8. [Step 5: 2連休の確保](#8-step-5-2連休の確保)
9. [優先度計算の仕組み](#9-優先度計算の仕組み)
10. [フローチャート](#10-フローチャート)
11. [よくある質問](#11-よくある質問)

---

## 1. はじめに：このシステムは何をするのか

### 🎯 目的

**12名のスタッフに1ヶ月分のシフトを自動で割り当てる**

手動でシフトを組むと：
- 時間がかかる（数時間〜丸1日）
- ミスが起きやすい（制約違反を見落とす）
- 不公平になりがち（特定の人に偏る）

このアルゴリズムは、これらの問題を解決します。

### 📋 入力と出力

```
【入力】
├── スタッフリスト（12名）
├── 日付リスト（16日〜翌15日の約31日間）
├── 希望休（事前に入力された休み）
└── 設定（制約条件、必要人数など）

【出力】
└── 各スタッフの各日の勤務（24A, 24B, 日勤, 明, 休 など）
```

---

## 2. 勤務の種類と制約ルール

### 🏷️ 勤務種別

| 勤務 | 労働時間 | 説明 |
|------|----------|------|
| **24A** | 16時間 | 24時間交代勤務（Aチーム） |
| **24B** | 16時間 | 24時間交代勤務（Bチーム） |
| **夜勤** | 9時間 | 夜間のみの勤務 |
| **日勤** | 8時間 | 日中の勤務 |
| **明** | 0時間 | 24勤の翌日（休養） |
| **休** | 0時間 | 休日 |
| **有休** | 0時間 | 有給休暇 |

### ⚠️ 守るべきルール（制約）

#### 必須制約（絶対に守る）

```
1. 24勤の翌日は必ず「明」
   → 24A → 明 → ... （24時間働いたら翌日は休養）

2. 希望休は上書きしない
   → スタッフが事前に入れた「休」「有休」は絶対保護

3. 1日あたり24勤は3名必要
   → 毎日最低3名が24時間体制で勤務
```

#### 推奨制約（できるだけ守る）

```
4. 連続24勤は2回まで
   → 24A → 明 → 24A → 明 → 休 （3連続はNG）

5. 月間労働時間は160〜176時間
   → 働きすぎ・働かなすぎを防ぐ

6. 月1回以上の2連休
   → 休 → 休 のパターンを確保

7. 同じペアが連続しない
   → 昨日と同じメンバーが今日も24勤にならないように
```

---

## 3. アルゴリズムの全体像

### 🔄 2段階アプローチ

このアルゴリズムは**2段階**で動作します：

```
【第1段階】全体配分
   └── 各スタッフに「何回24勤をするか」を決める

【第2段階】日次割り当て
   └── 1日ずつ「誰がどのシフトか」を決める
```

### なぜ2段階？

**1段階（日付順に割り当てるだけ）の問題点：**
- 月初に24勤が集中してしまう
- 月末に24勤できる人がいなくなる
- 希望休が多いスタッフに負担が偏る

**2段階のメリット：**
- 事前に「この人は○回24勤」と決める
- 希望休を考慮した公平な配分
- 月全体を見通した計画的な割り当て

---

## 4. Step 1: 事前準備

### 📌 処理の流れ

```javascript
// 1. 日勤専門スタッフを除外
const dayShiftOnlyStaff = [...]; // 24勤に入らない人
const shiftStaff = [...];        // 24勤に入る人

// 2. 希望休を保存
const savedRestDays = {};
// 例: { "田中": { "2025-01-20": "休", "2025-01-21": "休" } }

// 3. 既存のシフトをクリア（希望休以外）
clearAllSchedulesExceptRest(savedRestDays);

// 4. 希望休を復元
Object.keys(savedRestDays).forEach(staffName => {
    // 保存した希望休を画面に戻す
});
```

### 💡 ポイント

**なぜ一度クリアして復元するのか？**

```
自動アテンド前    自動アテンド後
┌──────────┐    ┌──────────┐
│ 24A │    │    │ 24A │ 明 │  ← 自動配置
│ 休  │    │ → │ 休  │    │  ← 希望休は保護
│     │    │    │ 24B │ 明 │  ← 自動配置
└──────────┘    └──────────┘
```

希望休を一度保存してからクリアすることで：
- 前回の自動アテンド結果を消去
- 希望休だけを残す
- 新しい結果を上書き

---

## 5. Step 2: スタッフの配置可能性を計算

### 📊 staffAvailability の計算

```javascript
const staffAvailability = {};

shiftStaff.forEach(staff => {
    let availableDays = 0;    // 24勤を配置できる日数
    let restDaysCount = 0;     // 希望休の日数
    
    dates.forEach((dateInfo, idx) => {
        // 希望休があるか？
        if (savedRestDays[staff]?.[dateInfo.date]) {
            restDaysCount++;
        } else {
            // 翌日も空いているか？（24勤+明で2日必要）
            const nextIsRest = savedRestDays[staff]?.[nextDate];
            if (!nextIsRest) {
                availableDays++;
            }
        }
    });
    
    staffAvailability[staff] = {
        availableDays: availableDays,
        maxPossible24Shifts: Math.floor(availableDays / 2)
    };
});
```

### 🎯 なぜこの計算が必要？

**例：田中さん（希望休3日）と佐藤さん（希望休0日）**

```
田中さん: 31日 - 3日 = 28日使える
         28日 ÷ 2 = 最大14回の24勤が可能

佐藤さん: 31日 - 0日 = 31日使える
         31日 ÷ 2 = 最大15回の24勤が可能
```

→ 田中さんに15回24勤を割り当てようとしても無理
→ 事前に「配置可能な最大回数」を計算しておく

---

## 6. Step 3: 24勤の割り当て

### 🎯 目標回数の動的設定

```javascript
// 全体で必要な24勤の総数
const total24ShiftNeeded = 93; // 31日 × 3人

// 各スタッフの配置可能数の合計
const totalAvailableCapacity = 100; // 全員の合計

// 按分して目標回数を設定
shiftStaff.forEach(staff => {
    const availability = staffAvailability[staff];
    
    // 配置可能数に応じて按分
    target24ShiftCount[staff] = Math.floor(
        (availability.maxPossible24Shifts / totalAvailableCapacity) * total24ShiftNeeded
    );
});
```

### 📅 日付ごとの割り当て

```javascript
dates.forEach((dateInfo, dateIndex) => {
    // 1. 候補者を取得（優先度付き）
    const candidates = getShiftCandidatesWithForwardLooking(...);
    
    // 2. 優先度でソート
    candidates.sort((a, b) => a.priority - b.priority);
    
    // 3. 上位3名を24勤に割り当て
    let assigned = 0;
    candidates.forEach(candidate => {
        if (assigned < 3 && candidate.canAssign) {
            schedule[candidate.staff][dateInfo.date] = '24A' or '24B';
            
            // 翌日に「明」を配置
            schedule[candidate.staff][nextDate] = '明';
            
            assigned++;
        }
    });
});
```

### ⚖️ 候補者選定のルール

```
候補から除外される条件：
├── 既にその日にシフトがある
├── 希望休が入っている
├── 前日が24勤（連続24勤になる）
├── 翌日が希望休（「明」を配置できない）
├── 連続24勤が上限に達している
└── 月間労働時間を超えてしまう
```

---

## 7. Step 4: 日勤で時間を補完

### 📊 時間不足の補完

24勤だけでは労働時間が足りないスタッフに日勤を追加：

```javascript
shiftStaff.forEach(staff => {
    // 現在の労働時間を計算
    let currentHours = 0;
    dates.forEach(dateInfo => {
        const shift = schedule[staff][dateInfo.date];
        if (hour24Shifts.includes(shift)) {
            currentHours += 16; // 24勤は16時間
        }
    });
    
    // 最低目標（144時間）に達していない場合
    if (currentHours < 144) {
        // 空いている平日に日勤を配置
        dates.forEach(dateInfo => {
            if (currentHours < 176 && isWeekday && canReplace) {
                schedule[staff][dateInfo.date] = '日勤';
                currentHours += 8;
            }
        });
    }
});
```

### 💡 なぜ日勤で補完？

```
例：山田さん
├── 24勤 8回 × 16時間 = 128時間
├── 目標: 176時間
└── 不足: 48時間

→ 日勤 6回 × 8時間 = 48時間を追加
→ 合計: 128 + 48 = 176時間 ✅
```

---

## 8. Step 5: 2連休の確保

### 🏖️ 連続休暇の重要性

```javascript
function ensureConsecutiveRestDays(...) {
    shiftStaff.forEach(staff => {
        // 既に2連休があるか確認
        let hasConsecutiveRest = checkHasConsecutiveRest(staff);
        
        if (!hasConsecutiveRest) {
            // 2連休を作れる場所を探す
            // 条件：前日が24勤でない、翌日が24勤でない
            
            const bestCandidate = findBestSlot(...);
            
            if (bestCandidate) {
                schedule[staff][bestCandidate.date1] = '休';
                schedule[staff][bestCandidate.date2] = '休';
            }
        }
    });
}
```

### ⚠️ 注意点

```
2連休を作れない条件：
├── 労働時間が最低目標を下回る場合
├── 24勤の翌日（「明」が必要）
└── 既に希望休で埋まっている
```

---

## 9. 優先度計算の仕組み

### 🧮 priority（優先度）の計算式

```javascript
priority = 
    samePairPenalty           // ペア連続防止
  + hoursBalancePenalty       // 時間均等化
  + progressPenalty           // 進捗率ベース
  + riskPenalty;              // 残り日数リスク
```

### 📈 各ペナルティの意味

#### 1. samePairPenalty（ペア連続防止）

```
昨日の24勤: 田中, 佐藤
今日の候補: 田中 → +100,000 ペナルティ
          山田 → 0（ペナルティなし）

→ 山田が優先される
```

#### 2. hoursBalancePenalty（時間均等化）

```
平均労働時間: 80時間
田中の労働時間: 96時間 → +1,600 ペナルティ（超過分×100）
佐藤の労働時間: 64時間 → -1,600 ペナルティ（不足分×100）

→ 佐藤が優先される（平均以下なので）
```

#### 3. progressPenalty（進捗率ベース）

```
目標24勤回数: 10回
現在: 月の中盤（50%経過）
期待進捗: 5回

田中: 3回完了 → 2回遅れ → -20,000 ペナルティ（優先UP）
佐藤: 6回完了 → 1回先行 → +10,000 ペナルティ（優先DOWN）

→ 田中が優先される（遅れを取り戻すため）
```

#### 4. riskPenalty（残り日数リスク）

```
田中: 目標残り5回、残り8日 → リスク高
佐藤: 目標残り5回、残り15日 → リスク低

→ 田中が優先される（日数的に余裕がないため）
```

### 🎲 同点時のランダム化

```javascript
candidates.sort((a, b) => {
    const diff = a.priority - b.priority;
    if (diff !== 0) return diff;
    // 同じ優先度の場合はランダムに
    return Math.random() - 0.5;
});
```

→ リストの上位スタッフに偏らないようにする

---

## 10. フローチャート

```
┌─────────────────────────────────────────┐
│           自動アテンド開始               │
└─────────────────┬───────────────────────┘
                  ▼
┌─────────────────────────────────────────┐
│  Step 1: 事前準備                        │
│  ├── 日勤専門スタッフを分離              │
│  ├── 希望休を保存                        │
│  └── 既存シフトをクリア                  │
└─────────────────┬───────────────────────┘
                  ▼
┌─────────────────────────────────────────┐
│  Step 2: 配置可能性を計算                │
│  └── 各スタッフが最大何回24勤できるか    │
└─────────────────┬───────────────────────┘
                  ▼
┌─────────────────────────────────────────┐
│  Step 3: 24勤の目標回数を設定            │
│  └── 配置可能性に応じて按分              │
└─────────────────┬───────────────────────┘
                  ▼
┌─────────────────────────────────────────┐
│  Step 4: 日付ごとに24勤を割り当て        │
│  ├── 候補者を優先度でソート              │
│  ├── 上位3名を選択                       │
│  ├── 人数不足なら制約を緩和              │
│  └── 翌日に「明」を配置                  │
└─────────────────┬───────────────────────┘
                  ▼
┌─────────────────────────────────────────┐
│  Step 5: 日勤で時間を補完                │
│  └── 労働時間が足りないスタッフに日勤追加│
└─────────────────┬───────────────────────┘
                  ▼
┌─────────────────────────────────────────┐
│  Step 6: 未割り当て日を「休」に          │
└─────────────────┬───────────────────────┘
                  ▼
┌─────────────────────────────────────────┐
│  Step 7: 2連休を確保                     │
│  └── 月1回以上の連続休暇                 │
└─────────────────┬───────────────────────┘
                  ▼
┌─────────────────────────────────────────┐
│           画面にスケジュールを表示        │
└─────────────────────────────────────────┘
```

---

## 11. よくある質問

### Q1: なぜ完璧な解を求めないのか？

**A**: シフトスケジューリングは「NP困難」と呼ばれる問題で、完璧な解を探すと計算時間が爆発的に増えます。

```
完璧を求めた場合：
├── 12人 × 31日 × 6種類 = 2,232通りの組み合わせ
├── 全探索すると...天文学的な計算量
└── 数時間〜数日かかる可能性

このアルゴリズム：
├── 貪欲法（Greedy）ベース
├── 「十分良い解」を高速に見つける
└── 数秒で完了
```

### Q2: 「制約緩和」とは何か？

**A**: 厳しい制約では解が見つからない場合、制約を緩めて解を探す仕組みです。

```
通常モード：
├── 月間労働時間 ≤ 176時間
├── 連続24勤 ≤ 2回

緩和モード：
├── 月間労働時間 ≤ 200時間
├── 連続24勤の制限なし
```

### Q3: 手動で修正した後、再計算されるか？

**A**: されます。シフトを変更すると、以下が自動更新されます：
- 合計労働時間
- 休日カウント
- 集計欄の表示

### Q4: 希望休が多すぎるとどうなるか？

**A**: アルゴリズムは以下の順で対応します：

1. 希望休を絶対保護
2. 残りのスタッフで24勤を配分
3. それでも足りない場合、制約を緩和
4. 最悪の場合、警告を表示して手動調整を促す

### Q5: このアルゴリズムの限界は？

**A**:
- **最適解ではない**: 数学的に「一番良い」解ではなく「十分良い」解
- **大規模対応不可**: 100人以上のスタッフには向かない
- **複雑な希望に未対応**: 「この人とは一緒に働きたくない」等の人間関係制約

---

## 📝 まとめ

このアルゴリズムは：

1. **2段階アプローチ** で公平性を確保
2. **優先度計算** で最適な候補を選択
3. **制約緩和** で解の存在を保証
4. **ランダム化** で偏りを防止

「完璧」ではなく「実用的」な解を高速に生成することを目指しています。

---

## 📚 参考リンク

- [制約充足問題 (CSP) - Wikipedia](https://ja.wikipedia.org/wiki/%E5%88%B6%E7%B4%84%E5%85%85%E8%B6%B3%E5%95%8F%E9%A1%8C)
- [貪欲法 (Greedy Algorithm) - Wikipedia](https://ja.wikipedia.org/wiki/%E8%B2%AA%E6%AC%B2%E6%B3%95)
- [ナーススケジューリング問題](https://ja.wikipedia.org/wiki/%E3%83%8A%E3%83%BC%E3%82%B9%E3%82%B9%E3%82%B1%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E5%95%8F%E9%A1%8C)

---

*最終更新: 2025年11月*

